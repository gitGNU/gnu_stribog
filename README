Stribog the sensing platform README file.

For license and copyright notes read 'copyright'.

ATTENTION stribog is in his alpha stage. he is not functional yet.

The project is located at http://savannah.nongnu.org/projects/stribog

SOME TECHNICAL NOTES

This project consists of hardware and software sections. the former is
developed with gEDA, the latter with GNU toolchains.

Hardware contains a 3-axis {magnetoresistive compass, accelerometer,
(optionally) gyroscope} and an ARM-based microcontroller to manage all.

Software includes programs for MCU to test and align hardware parts,
to perform the measurements; the software part also has some programs
for POSIX host to receive obtained data.

Stribog is primarily designed on LPC2138, but actually LPC213[46] can be used,
too. the only change will be in ld scripts (2138.ld and ram2138.ld), as shown 
in comments there.

The board will be programmed via serial port using bootstrap loader.
you can use any existing one (on Unix live 
lpc_host_tools by Holly Gates <hgates@eink.com>, 
lpc21isp by Martin Maurer <Martin.Maurer@clibb.de> 
 and Aeolus Development http://aeolusdevelopment.com
lpc2k_pgm by Paul Stoffregen (http://www.pjrc.com/arm/lpc2k_pgm)

on Windows they have Philips flash ISP utility)

If you use them, you'll have to adjust input files format (.hex, .srec 
and so on) with arm-elf-objcopy(1).

I wrote my own host tools (see sw/host/*) because
 1) some of those programs (like lpc21isp) lack clear terms of use,
 2) other (like Philips utility) are neither free nor capable to run 
    on a free OS,
 3) some (like lpc2k_pgm) have graphic user interface and I don't like this,
 4) I wouldn't add external dependencies when possible.

My tools are hardly functional, but they work somehow for me and they are free.

There are two linker scripts in sw/target/src directory: ram2138.ld and
2138.ld.  the former is used to link the program which will be loaded via elk
into RAM and run immediately. the latter used for programs saved in LPC2138 ROM;
on startup the program will be loaded into RAM and run there.
as of Feb 2008 programs don't always work correctly when linked with ram2138.ld:
usually it either work well or don't work at all.

The programs are written in C (the ld scripts don't support C++). 
main() is executed in supervisor mode. no THUMB code. fast interrupt reserved. 
VPB divider equals 4, as by default. PLL is configured to multiply by 4.

The programs will run from RAM, when possible. even when written in ROM, boot.s
will copy it to RAM. the program uses single library: libgcc.a. 
all computations should be in fixed point.

Busy VIC slots: 3 (timer0), 4 (timer1), 5 and 6 (ADC), 7 (UART1), 8 (UART0) 

Time functions (tempus.h) are based on timer1. it uses VIC vectored interrupt
slot 4. this module receives PPS at CAP1.2 (signal A), too.

UART0 is the auxiliary port to get GPS data; uses VIC slot 8

UART1 is the basic port; uses VIC slot 7

ADC use VIC slots 5 and 6; magnetic module functions used in such way
(see magex.c, multa.c) that ADC sampling frequency defines frequency of
set/reset pulses. this frequency is adjusted to be an integer of 50 Hz.

Magnetoresistive sensors work not so far from the absolute maximum value 
for set/reset strap duty cycle. carelessly increasing the sampling frequency 
can DAMAGE the sensors.

Timer0 is occupied by accelerometers; VIC slot 3

HOW TO INSTALL DEVELOPMENT TOOLS

First, we shall need binutils and gcc for ARM. we go to http://www.gnu.org and
get binutils and gcc. generally, we use the latest releases, though there is 
nothing dependent on any supernew features in stribog. currently we use 
binutils-2.18 with gcc-4.2.3. we used also binutils-2.17, binutils-2.16.1, 
binutils-2.16, gcc-3.4.6, gcc-4.0.1, gcc-4.0.3, gcc-4.1.1, gcc-4.1.2,
gcc-4.2.2.

Older versions are to be tested.

Follow (with some changes) instructions from http://www.gnuarm.com
($ is for our shell prompt)
$ export armprefix=$HOME/arm
                   (or where you want them to live. you must have write access
		    thither)
$ gpg --verify binutils-2.18.tar.bz2.sig && tar xjf binutils-2.18.tar.bz2
$ mkdir bui;cd bui
$ ../binutils-2.18/configure --target=arm-elf --prefix=$armprefix --enable-interwork --enable-multilib
$ make all install
$ export PATH=$armprefix/bin:$PATH; rm -fr *;cd ..
         (add this path in your shell profile after install, too)
$ gpg --verify gcc-4.2.3.tar.bz2.sig && tar xjf gcc-4.2.3.tar.bz2;cd bui
$ ../gcc-4.2.3/configure --target=arm-elf --prefix=$armprefix --enable-interwork --enable-multilib --enable-languages=c
$ make all-gcc install-gcc

That's all. we don't need newlib, and stribog main board has no contacts 
to connect with gdb.

This sequence worked on Fedora Core 4 (32-bit).
On RedHat 7.3 binutils-2.18 will not build themselves without
manual intervention. binutils-2.17 with gcc-4.2.3 work just fine;
generally, binutils-2.18 release is not very stable.

GCC-4.3.0 has a new strong dependency, MPFR. current version of MPFR, 2.3.1,
requires gmp-4.1 or later; RedHat 7.3 has gmp-4.0.1.
not all. gcc-4.3.0 outputs 'libgcc.a' when asked for -print-libgcc-file-name;
-print-file-name=$(arm-elf-gcc -print-libgcc-name) does not work, too.
evidently the feature is broken.
the older versions printed the absolute path to the library; and -lgcc worked
with them and does not with gcc-4.3.0.


Auxiliary targets (such as sw/auxilia/odo and sw/auxilia/coil) are based on
AVR. their target programs are built with avr-binutils, avr-gcc and avr-libc.
instructions how to build this toolchain can be found in avr-libc 
documentation. for historical reasons we use uisp to load programs into these 
processors. generally avrdude is much better. they all live in 
http://savannah.gnu.org

It is much more problematic to install gEDA and friends. you'll need them if
you want to edit the hardware part of stribog.

ARM tools are necessary to program the main board, since the software 
must be configured at compile time (LPC2138 is not so fat to configure
at run time).

AVR tools will be needed only if you use auxiliary targets. if you
are to use auxiliary programs only, just build them as a separate project.

The gEDA are required to edit the hardware part. executable files needed
to produce the board like GERBERs are included into the distribution.
this is possible because these targets are not configurable.

HOW TO BUILD (as of Mar 2008)

In order to build you will need
1. native C compiler
2. ARM tools (you have an arm-elf-gcc BUILD? then you are lucky)
3. AVR crosstools (in the future, when auxiliary
   software is mounted on the GNU build system)
The executables are not distributed because you will need to
configure them in any case.

GERBERS and schematic PNGs will be distributed, 
because the boards and schematics are not configurable and
we don't want to force you to (figure out and) install a gEDA
version compatible with ours.

Stribog use GNU-standard configuration procedure
(see INSTALL). Though general build versus source directory
positions should work, the usual way is to build the project 
in a separate directory out of the source tree, so
the configure invocation sounds like this:

../stribog/configure --prefix=$HOME/stribog

Currently, this procedure has been adopted for programs
in sw/host and sw/target only. for instructions on using host tools
read sw/host/README.
auxiliary software is built with GNU make utility.
GERBER and EXCELLON files are produced manually with PCB.

HOW TO REGENERATE BUILD SYSTEM

You should need this only to improve the configuring scripts
and to change the structure of the sources (add/remove source files
and so on). you typically shall not want this.

The configuring scripts are updated by scripts 'regen_configure'.
The scripts recurse into the subdirectories. if a directory
has 'configure' script but no 'regen_configure', then
the build system is regenerated with
'autoreconf -v'; you may 'rm -r autom4te.cache' after that.

As of Mar 2008, the versions used are autoconf-2.61 and automake-1.10.

HOW TO USE GIT

Git is the revision control system used by the project.

To see meta-documentation on the project branches, 
checkout 'master' branch and read the files it contains.

Here is a typical ~/.gitconfig file contents
(please replace the names and email with yours):
<<EOF
[user]
 name = Ineiev (favourite host)
 email = ineiev@users.sourceforge.net
[core]
 editor = vim
EOF

If you are a maintainer, your usual spells are
(replace ineiev with your login name)

$ git clone ineiev@git.savannah.nongnu.org:/srv/git/stribog.git
 to get a new local repository

$ git remote add savannah ineiev@git.savannah.nongnu.org:/srv/git/stribog.git
 to add a reference for the public repository

$ git push savannah feb2008
 to push into savannah local branch named 'feb2008' 
 (non-existent will be created)

$ git push savannah
 to push into savannah all local branches

$ git push savannah :refs/heads/feb2008
 to remove branch feb2008 from remote savannah

For anonymous access, use these:

$ git clone git://git.savannah.nongnu.org/stribog.git
 to make your local repository

$ git checkout -b feb2008 origin/feb2008
 to make a local branch feb2008 based on fetched origin/feb2008

$ git fetch
 to update copies of remote branches

$ git pull
 to fetch all remote branches and merge
 one of them into your current branch

Common to both access types:

$ git checkout master
 to switch to existing branch 'master'

$ git add .
 to cache the changes in your files against
 the current branch most recent commit

$ git diff
 to see what will be "git add"ed

$ git diff --cached
 to see what has been "git add"ed but not 
 "git commit"ed

$ git branch
 to list the local repository branches

$ git branch -r
 to list the public repositories branches

$git commit
 to move the changes to your current branch

$git show
 to see the latest commit description

$git status
 to see what files are not in sync with the current branch

What will go to Git

We currently don't put into the repository gEDA-generated files.
however, we do put all Autotools-generated files
that will be distributed.

The general rules are to be worked on yet; the bottomline consideration
should be that Git serves as a source of most recent package version.

Now we think that today state may be right because
1. the schematics and PCB layouts change slowly; the real result
  is a material board populated with elements rather than a file. it takes
  time and money to reproduce such a board. so, there is almost no chance
  that the programs in Git work with Git PCBs and won't work with the PCBs
  of the most recent release (wich certainly includes printed layouts).
2. after a compatible version of gEDA has been installed, there is
  no difficulty to reproduce the GERBERS and schematics. it is easier
  than fix anything in the layout file.
3. As of the software, if there is no build scripts, the programs
  can't be developped. this would be wrong because the programs
  can be modified and rebuilt very quickly and at no cost.
  to rebuild the scripts one must have a compatible Autotools version
  installed; but this is not enough. the configuration process is
  very uniform and straightforward; the regeneration of the scripts
  is not trivial and probably package-specific, it generally requires some knowledge
  of several languages other than C, so it can take a lot of time
  when done by a person new to the package. this can be much harder
  than just fix a bug or add even a complicated feature.
